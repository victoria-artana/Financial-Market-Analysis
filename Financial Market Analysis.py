# -*- coding: utf-8 -*-
"""Hay que agregar el nombre del archivo a las exepciones.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1H93kMbtBk2SNz6pKVzqI7ReIvJLmiZSc

# **Curso Introductorio de Python - Proyecto Integrador**

<img width="320" src="https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/_assets/logo-oficial.png">

En este proyecto final podrán integrar los conocimientos adquiridos a lo largo del curso implementando una aplicación práctica que esperamos sirva como un puntapié inicial para la creación de muchos más proyectos en su futuro de todo tipo de complejidad.

**Objetivos del proyecto**:

*   Que el participante domine las bases de la programación en Python.
*   Que el participante tenga conocimientos elementales sobre la lectura de archivos, procesamiento de datos, y visualización de datos.
*   Que el participante pueda encontrar y aplicar conocimientos que vayan más allá de los explicados en el curso.
*   Que el participante tenga una experiencia de aplicación de la programación Python a un ejemplo práctico.

Se presentan diferentes opciones de proyectos, de dificultad comparable, para que cada uno pueda elegir el que considere más interesante, es decir que deben realizar uno sólo de los proyectos entre las opciones.

**Fecha de entrega**:
 * **22 de Noviembre de 2020**

**Modalidad de entrega**:
 * **El archivo *.py* y los archivos *.PNG* se deben enviar a través de un [formulario en nuestro foro](https://curso.whittileaks.com/f/Curso-Python2020/sub/), utilizando su usuario.**

**Detalles de la entrega:**

*   Se debe entregar **1 único archivo *.py*** con su código en Python que podría ser descargado directamente desde Google Colaboratory, o editado con otro software a su elección. Normalmente se utilizan muchos archivos en un mismo proyecto, pero para este caso les pedimos unificar todo para simplificar el proceso de entrega y corrección.

*   En el archivo del código en Python **se valorará en la corrección las explicaciones del funcionamiento del programa y los razonamientos de su solución**. Esto pueden realizarlo mediante comentarios en el código.

*   Además del código en Python, **deberán enviar un gráfico** en formato *.PNG* generado usando *matplotlib* **siguiendo las indicaciones en la descripción del proyecto**. Esto les sirve a ustedes y a nosotros para saber que se encuentran en buen camino.

*   El programa debe ser **robusto**, es decir, con pocas probabilidades de fallar al alterar su entrada. Si el formato de la entrada del usuario no es el esperado **el programa no debe *crashear***, sino manejar la situación acordemente. Una estrategia para detectar posibles fallos es imaginarse que una persona esta empeñada en producir un error en su programa y pensar: **¿Qué intentaría esta persona para romper el código?** Esto involucra, por ejemplo, contemplar casos en que el usuario ingrese texto cuando se esperaba un número, o que ingrese un valor desconocido, una clave que no se encuentra en un diccionario, un índice mayor al tamaño de una lista, etc.

*   Tienen libertad de usar su propio criterio para decidir como implementar aquellos detalles que no estén especificados en la descripción.

*   La descripción de los proyectos especifica las características mínimas que deben tener. **Damos libertad para agregar funcionalidad o mejorar el proyecto si así lo desean, en tanto se cumpla con todos los requisitos mínimos detallados en la descripción**.

**Corrección:**

*   Si el proyecto es aprobado se otorgará un certificado digital por haber completado el curso.

*   Si se considera que el proyecto aún tiene detalles por corregir se les podrá pedir una re-entrega en una fecha posterior.

**Consultas acerca del proyecto:**

* Podrán realizar todas las consultas que quieran a través de [nuestro foro](https://curso.whittileaks.com/f/Curso-Python2020/c/Proyecto-Integrador/), teniendo especial cuidado de no mostrar grandes partes de su solución ya que si consideramos que el comentario tiene un *spoiler* importante será eliminado.

# **Opción 1: Graficador de casos del COVID-19**

#### *Análisis y visualización de datos sobre los casos de coronavirus en distintos países.*

<img height="300" src="https://cdn.pixabay.com/photo/2020/02/04/16/53/hand-washing-4818792_960_720.jpg">

En esta era de la desinformación puede resultar útil poder sacar uno mismo sus propias conclusiones acerca de los datos presentados. El objetivo de este trabajo es obtener datos de casos y muertes por el Coronavirus de un repositorio de datos online y graficar por país.

**Funcionalidad mínima (requisito):**

* La aplicación debe recibir del usuario el nombre del país deseado y permitir graficar casos detectados y fallecimientos totales para ese país en función del tiempo.
* El usuario debe poder ingresar 2 países y se permite graficar para dichos países la cantidad de casos y fallecimientos en dos gráficos con labels. El usuario debe poder ingresar el intervalo de tiempo a graficar. Calcular las intersecciónes entre gráficos si las hubiera y marcarlas con un punto de algún tipo.
* El usuario debe poder ingresar *n* países y se permite graficar para dichos países la cantidad de casos en una [escala logaritmica](https://es.wikipedia.org/wiki/Escala_logar%C3%ADtmica). El programa debe pedirle al usuario el intervalo de tiempo deseado.

**Gráfico a entregar (requisito):**

* Gráficar sobre la misma imagen la cantidad de casos en una [escala logaritmica](https://es.wikipedia.org/wiki/Escala_logar%C3%ADtmica) de Argentina y todos sus países limítrofes (Chile, Bolivia, Paraguay, Brasil y Uruguay) durante los meses de invierno (21 de junio a 21 de septiembre). Debe quedar claro la curva que corresponde a cada país.

**Funcionalidad opcional:** *Pueden realizar todos, algunos, o ninguno de los siguientes ítems. También pueden agregar otra funcionalidad que se les ocurra a ustedes en tanto cumpla con la funcionalidad mínima.*

* El programa debe permitir almacenar en un archivo excel los países ordenados de mayor cantidad de casos totales acumulados (al día de hoy) a menor cantidad de casos indicando en las distintas columnas el nombre del país, la cantidad de casos y los fallecimientos.

* Almacenar en un archivo excel los países ordenados de mayor cantidad de casos totales acumulados a menor cantidad de casos indicando en las distintas columnas el nombre del país, la cantidad de casos y los fallecimientos colocando en distintas hojas del archivo excel (distintas pestañas) la evolución de este ranking, es decir armar una hoja distinta para cada día transcurrido. Defina los días a utilizar acorde a cuanta información se disponga, podría ser una entrada del usuario.

* Para cada gráfico generado el usuario deberá poder ingresar un nombre de archivo y el programa genera un archivo *.PNG* del gráfico con el nombre indicado.

* Crear una aplicación de consola que se ejecute continuamente recibiendo comandos del usuario, el usuario debe indicar el modo de operación que desea y el programa le pide los datos requeridos. Luego de finalizar la tarea el programa regresa al inicio y le pide al usuario el próximo comando. Incluír un comando de *ayuda* para que el programa indique al usuario cómo utilizarlo. Incluír un comando de *salida* que provoca la finalización del programa.

**Sugerencia:**
*   Se pueden rotar las leyendas usando `plt.xticks(rotation=60)` (rotación de 60 grados). Es útil para leyendas largas, como por ejemplo, fechas.
*   En esta [página web](https://nexiandigitalacademy.es/visualizacion-y-procesamiento-de-datos-ante-de-la-pandemia-del-covid-19/) hay un ejemplo de gráficos logaritmicos

wget 'https://covid.ourworldindata.org/data/ecdc/full_data.csv'
"""


"""# **Opción 2: El mercado financiero**

#### *Estudio comparativo del desempeño financiero de distintas empresas*.

<img height="300" src="https://cdn.pixabay.com/photo/2016/11/27/21/42/stock-1863880_960_720.jpg">

Puede ser muy útil visualizar la información del mercado financiero para sacar conclusiones, en esta opción de proyecto la idea es estudiar comparativamente el desempeño de dos o más empresas en la bolsa.

**Funcionalidad mínima (requisito):**

*   Armar un programa donde se analize la información de ciertas empresas (entrada del usuario) y se las grafique comparativamente.
*   El usuario debe poder seleccionar empresas de una lista de opciones y el programa debe calcular las intersecciones entre los precios de ambas. Se debe permitir graficar esta información de forma gráfica y almacenar en un archivo de excel las fechas donde ocurrieron las intersecciones.
*   Se debe permitir graficar la *derivada discreta* de los valores de bolsa de cada empresa, esto es, la diferencia entre el valor actual y el anterior para cada punto en el tiempo.
*   El programa debe poder calcular cuál es aquella que creció más y aquella que creció menos en el mes pasado (Octubre), en el mes anterior (Septiembre) y los últimos 12 meses, esta información se debe poder almacenar en un archivo excel.

**Sugerencia**: En esta [base de datos](https://github.com/scikit-learn/examples-data/tree/master/financial-data) esta la información de bolsa de muchas empresas, también en algunos sitios como [Yahoo Finance](https://finance.yahoo.com/) o [investing.com](https://www.investing.com/) pueden buscar información del estado de la bolsa de las empresas en formato csv o excel.

**Gráfico a entregar (requisito):**

*   Realizar un gráfico del valor de las acciones diarias de las compañias **Amazon** y **Google** utilizando dos tipos de lineas distintos. El intervalo de fechas que se desea gráficar debe ser seleccionado por el usuario. Encontrar los puntos donde se cruzan los dos gráficos y marcarlos con puntos (para este caso elegir un intervalo donde se produzcan cruces).
"""

# Librerías utilizadas
# Función para limpiar la consola


# Nombres de archivos y la extensión
from time import sleep
import pandas as pd
import numpy as np
import matplotlib as mp
import datetime as dt
import matplotlib.dates as mdates
import matplotlib.pyplot as plt
import os
import requests
from IPython.display import clear_output
from time import sleep  # Para el anuncio de error
nomInter = 'Intersecciones.xlsx'
nomCrec = 'Crecimiento.xlsx'
nomGraf = 'Gráfico.png'
extensión = '.csv'


# Base de datos
urls = {
    '^DJI': 'https://query1.finance.yahoo.com/v7/finance/download/%5EDJI?period1=475804800&period2=1605830400&interval=1d&events=history&includeAdjustedClose=true',
    'AMZN': 'https://query1.finance.yahoo.com/v7/finance/download/AMZN?period1=863654400&period2=1605830400&interval=1d&events=history&includeAdjustedClose=true',
    'BABA': 'https://query1.finance.yahoo.com/v7/finance/download/BABA?period1=1411084800&period2=1605830400&interval=1d&events=history&includeAdjustedClose=true',
    'GOOG': 'https://query1.finance.yahoo.com/v7/finance/download/GOOG?period1=1092873600&period2=1605830400&interval=1d&events=history&includeAdjustedClose=true',
}

directorio = os.listdir()
# Descarga de los archivos si no existen en el directorio, para evitar repeticiones
for nombre, url in urls.items():
    if nombre + extensión not in directorio:
        archivo = requests.get(url)
        open(nombre + extensión, 'wb').write(archivo.content)


# Definición de funciones

# Función de cálculo de puntos de intersección
def calcInter(e1d, e2d, Date):
    i = 1
    inter = {'Date': [], 'Open': []}
    if e1d[-i] >= e2d[-i]:
        e1mayor = True
    elif e1d[-i] < e2d[-i]:
        e1mayor = False
    tendencia = e1mayor
    while i <= len(e1d) and i <= len(e2d):
        if e1d[-i] > e2d[-i]:
            e1mayor = True
        elif e1d[-i] < e2d[-i]:
            e1mayor = False
        else:
            inter['Open'].append(e1d[-i])
            inter['Date'].append(Date[-i])
        if tendencia != e1mayor:
            inter['Open'].append(e1d[-i])
            inter['Date'].append(Date[-i])
        tendencia = e1mayor
        i += 1
    return inter


# Función de derivada discreta
def deriv(lista):
    j = 0
    n = len(lista)
    d = []
    while j < n - 1:
        d.append(lista[j + 1] - lista[j])
        j = j + 1
    return d


# Función para validar fechas
def valid(a, m, d):
    booleano = False
    if dt.datetime.strptime(a + m + d, '%Y%m%d').date() <= dt.date.today() - dt.timedelta(days=1):
        # Año
        a = int(a)
        # Mes
        m = int(m)
        # Día
        d = int(d)
        if m >= 1 and m <= 12:
            if m == 1 or m == 3 or m == 5 or m == 7 or m == 8 or m == 10 or m == 12:
                if d >= 1 and d <= 31:
                    booleano = True
                else:
                    print('La fecha ingresada no es válida')
            if m == 4 or m == 6 or m == 9 or m == 11:
                if d >= 1 and d <= 30:
                    booleano = True
                else:
                    print('La fecha ingresada no es válida')
            # Consideraciones especiales de febrero en caso de ser o no bisiesto
            if m == 2:
                if d >= 1 and d <= 29:
                    if a % 4 != 0 and d == 29:
                        print('La fecha ingresada no es válida')
                    else:
                        booleano = True
        else:
            print('La fecha ingresada no es válida')
    else:
        print('Los datos son registros pasados, no se dispone de proyecciones')
    return booleano


# Función para validar números
def entero(n):
    try:
        n = int(n)
        n = str(n)
        return True
    except ValueError:
        print('El valor {} ingresado no es válido, debe ser un número entero'.format(n))
        return False


# Programa

# Lista de empresas disponibles
directorio = os.listdir()

# Eliminación de valores indeseados en la lista del directorio
if nomInter in directorio:
    directorio.remove(nomInter)
if nomCrec in directorio:
    directorio.remove(nomCrec)
if '.config' in directorio:
    directorio.remove('.config')
if 'sample_data' in directorio:
    directorio.remove('sample_data')
if '.ipynb_checkpoints' in directorio:
    directorio.remove('.ipynb_checkpoints')
if 'Gráfico.png' in directorio:
    directorio.remove('Gráfico.png')

# Definición de la lista de opciones
for x in range(0, len(directorio)):
    if '.csv' in directorio[x]:
        directorio[x] = directorio[x].replace(extensión, '')
print("Las opciones son:", directorio)

# Ingreso primera empresa
loop = True
while loop == True:
    e1 = input("Ingrese la primer empresa con la que desea trabajar: ").upper()
    if e1 in directorio:
        loop = False
    else:
        print('La empresa ingresada no se encuentra entre las opciones, vuelva a intentarlo')

# Ingreso segunda empresa
loop = True
while loop == True:
    e2 = input('Ingrese la segunda empresa con la que desea trabajar: ').upper()
    if e2 == e1:
        print('La empresa ya está seleccionada, ingrese otra')
    elif e2 in directorio:
        loop = False
    else:
        print('La empresa ingresada no se encuentra entre las opciones, vuelva a intentarlo')

# Definición de los data frame
e1df = pd.read_csv(e1 + ".csv")
e2df = pd.read_csv(e2 + ".csv")
pd.set_option('display.max_columns', 15)

# Definición de los diccionarios
e1d = e1df.to_dict("list")
e2d = e2df.to_dict("list")

# Definición de formato fechas
date1 = [dt.datetime.strptime(d, '%Y-%m-%d').date() for d in e1d['Date']]
date2 = [dt.datetime.strptime(d, '%Y-%m-%d').date() for d in e2d['Date']]

# Programa que compara dos empresas

# Graficos
plt.figure(figsize=[12, 4.8])
plt.plot(date1, e1d['Open'], 'g--', label=e1)
plt.plot(date2, e2d['Open'], 'm-', label=e2)
plt.title('Comparación de empresas')
plt.xlabel('Fechas')
plt.ylabel('Open')
plt.legend()


# Puntos de intersección
inter = calcInter(e1d['Open'], e2d['Open'], e1d['Date'])
dateint = [dt.datetime.strptime(d, '%Y-%m-%d').date() for d in inter['Date']]
# En caso de querer gráficar las intersecciones sobre el grafico anterior bastara con comentar la siguiente linea (plt.figure)
plt.figure(figsize=[12, 4.8])
plt.plot(dateint, inter['Open'], 'r.', label='Intersecciones')
plt.title('Intersecciones')
plt.xlabel('Fechas')
plt.ylabel('Open')
plt.legend()
plt.show()


# Exportación de las intersecciones a excel
archivo = pd.DataFrame(inter)
archivo.to_excel(nomInter)


# Derivada discreta
derivada1 = deriv(e1d['Open'])
derivada2 = deriv(e2d['Open'])
date_d1 = date1
date_d1.pop()
date_d2 = date2
date_d2.pop()

# Gráfico de la derivada discreta
plt.figure(figsize=[12, 4.8])
plt.plot(date_d1, derivada1, 'g--', label='Derivada discreta de ' + e1)
plt.plot(date_d2, derivada2, 'm-', label='Derivada discreta de ' + e2)
plt.title('Derivada discreta')
plt.xlabel('Fechas')
plt.ylabel('Valor de la derivada')
plt.legend()
plt.show()


# Crecimiento de empresas
crec1df = pd.read_csv(e1 + ".csv", index_col='Date')
crec2df = pd.read_csv(e2 + ".csv", index_col='Date')
crec1d = crec1df.to_dict("index")
crec2d = crec2df.to_dict("index")

# Definición del dia de incio de octubre
indicei = '2020-10-01'

# Se le agrega días en caso de que caiga en fin de semana ya que no hay valores para esos dias
if indicei not in crec1d:
    indicei = indicei[:-1] + str(int(indicei[-1:]) + 1)
if indicei not in crec1d:
    indicei = indicei[:-1] + str(int(indicei[-1:]) + 1)

# Definición del día de final de octubre
indicef = '2020-10-31'

# Se le resta días en caso de que caiga en fin de semana ya que no hay valores para esos dias
if indicef not in crec1d:
    indicef = indicef[:-2] + str(int(indicef[-2:]) - 1)
if indicef not in crec1d:
    indicef = indicef[:-2] + str(int(indicef[-2:]) - 1)

crec1 = crec1d[indicef]['Open'] - crec1d[indicei]['Open']
crec2 = crec2d[indicef]['Open'] - crec2d[indicei]['Open']

# Comparación de ambos crecimientos
if crec1 > crec2:
    print('La empresa que creció más en el mes de octubre es {}, con un valor de: {:.2f}\nLa empresa que creció menos en el mes de octubre es {}, con un valor de: {:.2f}'.format(e1, crec1, e2, crec2))
elif crec2 > crec1:
    print('La empresa que creció más en el mes de octubre es {}, con un valor de: {:.2f}\nLa empresa que creció menos en el mes de octubre es {}, con un valor de: {:.2f}'.format(e2, crec2, e1, crec1))
else:
    print('Ambas empresas experimentaron el mismo crecimiento en el mes de octubre, con un valor de: {}'.format(crec1))


# Definición del dia de incio del mes septiembre
indiceis = '2020-09-01'
if indiceis not in crec1d:
    indiceis = indiceis[:-1] + str(int(indiceis[-1:]) + 1)
if indiceis not in crec1d:
    indiceis = indiceis[:-1] + str(int(indiceis[-1:]) + 1)

# Definición del día de final del mes
indicefs = '2020-09-30'
if indicefs not in crec1d:
    indicefs = indicefs[:-2] + str(int(indicefs[-2:]) - 1)
if indicefs not in crec1d:
    indicefs = indicefs[:-2] + str(int(indicefs[-2:]) - 1)

crec1s = crec1d[indicefs]['Open'] - crec1d[indiceis]['Open']
crec2s = crec2d[indicefs]['Open'] - crec2d[indiceis]['Open']

# Comparación de ambos crecimientos
if crec1s > crec2s:
    print('La empresa que creció más en el mes de septiembre es {}, con un valor de: {:.2f}\nLa empresa que creció menos en el mes de septiembre es {}, con un valor de: {:.2f}'.format(e1, crec1s, e2, crec2s))
elif crec2s > crec1s:
    print('La empresa que creció más en el mes de septiembre es {}, con un valor de: {:.2f}\nLa empresa que creció menos en el mes de septiembre es {}, con un valor de: {:.2f}'.format(e2, crec2s, e1, crec1s))
else:
    print(
        'Ambas empresas experimentaron el mismo crecimiento en el mes de septiembre, con un valor de: {:.2f}'.format(crec1s))


# Definición del dia de incio del año
indiceia = '2019-11-20'
if indiceia not in crec1d:
    indiceia = indiceia[:-1] + str(int(indiceia[-1:]) + 1)
if indiceia not in crec1d:
    indiceia = indiceia[:-1] + str(int(indiceia[-1:]) + 1)

# Definición del día de final del año
indicefa = '2020-11-20'
if indicefa not in crec1d:
    indicefa = indicefa[:-2] + str(int(indicefa[-2:]) - 1)
if indicefa not in crec1d:
    indicefa = indicefa[:-2] + str(int(indicefa[-2:]) - 1)

crec1a = crec1d[indicefa]['Open'] - crec1d[indiceia]['Open']
crec2a = crec2d[indicefa]['Open'] - crec2d[indiceia]['Open']

# Comparación de ambos crecimientos
if crec1a > crec2a:
    print('La empresa que creció más en el año {0} es {1}, con un valor de: {2:.2f}\nLa empresa que creció menos en el año {0} es {3}, con un valor de: {4:.2f}'.format(
        indicefa[:4], e1, crec1a, e2, crec2a))
elif crec2a > crec1a:
    print('La empresa que creció más en el año {0} es {1}, con un valor de: {2:.2f}\nLa empresa que creció menos en el año {0} es {3}, con un valor de: {4:.2f}'.format(
        indicefa[:4], e2, crec2a, e1, crec1a))
else:
    print('Ambas empresas experimentaron el mismo crecimiento en el año {}, con un valor de: {:.2f}'.format(
        indicefa[:4], crec1a))


# Exportacion a excel
crecimientos = {'Empresa': [e1, e2], 'Crecimiento octubre': [crec1, crec2], 'Crecimiento septiembre': [
    crec1s, crec2s], 'Crecimiento anual (' + indicefa[:4] + ')': [crec1a, crec2a]}
archivoCrec = pd.DataFrame(crecimientos)
archivoCrec.to_excel(nomCrec)


# Ingreso de fechas para comparar empresas
loop = True
while loop == True:

    # Ingreso fecha inicial
    corte = False
    while corte == False:
        dia1 = input('\nIngrese el día inicial:')
        mes1 = input('Ingrese el mes inicial:')
        año1 = input('Ingrese el año inicial:')
        if entero(dia1) == True and entero(mes1) == True and entero(año1) == True:
            corte = valid(año1, mes1, dia1)

    # Definición de la fecha de inicio con su formato correspondiente
    fecha_inicio = año1 + '-' + mes1 + '-' + dia1
    fecha_inicio = dt.datetime.strptime(fecha_inicio, '%Y-%m-%d').date()
    e1d['Date'] = date1

    # Se considera nuevamente si cae en fin de semana
    if fecha_inicio not in e1d['Date']:
        fecha_inicio = fecha_inicio + dt.timedelta(days=1)
    if fecha_inicio not in e1d['Date']:
        fecha_inicio = fecha_inicio + dt.timedelta(days=1)

    # Ingreso de fecha final
    corte = False
    while corte == False:
        dia2 = input('\nIngrese el día final:')
        mes2 = input('Ingrese el mes final:')
        año2 = input('Ingrese el año final:')
        if entero(dia2) == True and entero(mes2) == True and entero(año2) == True:
            corte = valid(año2, mes2, dia2)

    # Definición de la fecha de inicio con su formato correspondiente
    fecha_final = año2 + '-' + mes2 + '-' + dia2
    fecha_final = dt.datetime.strptime(fecha_final, '%Y-%m-%d').date()

    # Se considera nuevamente si cae en fin de semana
    if fecha_final not in e1d['Date']:
        fecha_final = fecha_final - dt.timedelta(days=1)
    if fecha_final not in e1d['Date']:
        fecha_final = fecha_final - dt.timedelta(days=1)

    # Verificación si la fecha inicial es anterior a la final
    if fecha_final > fecha_inicio:
        loop = False
    else:
        print('La fecha de inicio debe ser anterior a la fecha final del período selecionado, vuelva a ingresar los datos')


# Definición de listas de los períodos definidos por el usuario
fecha_usu1 = []
fecha_usu2 = []
dato1_usu = []
dato2_usu = []
rango_usu1 = True
rango_usu2 = True

# Lista para la empresa 1 de los períodos definidos por el usuario
for largo in range(0, len(date1)):
    if rango_usu1 == True:
        if largo < len(date1) and fecha_inicio <= date1[largo]:
            fecha_usu1.append(date1[largo])
            dato1_usu.append(e1d['Open'][largo])
    if fecha_final <= date1[largo]:
        rango_usu1 = False

# Lista para la empresa 2 de los períodos definidos por el usuario
for largo2 in range(0, len(date2)):
    if rango_usu2 == True:
        if largo2 < len(date2) and fecha_inicio <= date2[largo2]:
            fecha_usu2.append(date2[largo2])
            dato2_usu.append(e2d['Open'][largo2])
    if fecha_final <= date2[largo2]:
        rango_usu2 = False


# Intersecciones del gráfico definido por el usuario
inter_usu = calcInter(dato1_usu, dato2_usu, fecha_usu1)

# Grafico definido por el usuario
plt.figure(figsize=[12, 4.8])
plt.plot(fecha_usu1, dato1_usu, 'g--', label=e1)
plt.plot(fecha_usu2, dato2_usu, 'm-', label=e2)
plt.plot(inter_usu['Date'], inter_usu['Open'], 'r.', label='Intersecciones')
plt.title('Comparación en rango')
plt.xlabel('Fechas')
plt.ylabel('Open')
plt.legend()
plt.savefig(nomGraf)
plt.show()


# Posibilidad de que se ingresen más de dos empresas (con una lista), quizá muy ambicioso, pero no sé por qué no lo empezamos haciendo así. Cosas a tener en cuenta, no puede haber más empresas seleccionadas que cantidad de empresas disponibles (que corte si el largo de la lista de empresas ingresadas igual al del directorio), comparar en cada ingreso que no se repitan, para los graficos usar un for o un while con el largo de la lista ingresada, que corte con un enter o un nada.

# Menú para realizar acciones después de ingresar las primeras 2 empresas
# Acciones:
# 1 - Gráfico comparativo
# 2 - Cálculo de intersecciones (crea intersecciones.xlsx, de existir el archivo lo sobreescribirá)
# 3 - Comparación de crecimientos en un período determinado (crea Crecimiento.xlsx, de existir lo sobreescirbirá)
# 4 - Cambiar empresas (empresas seleccionadas: )
# 5 - Cambiar formato de fecha (formato actual: )
# 6 - Salir o detener programa

# Para el menú probablemente tengamos que buscar como borrar lo que se muestra
# aca habria q comparar si esas fechas estan en los datos y extraer los valores

d = 24
m = 2
a = 900000
booleano = 0
if a <= 2020:
    if m >= 1 and m <= 12:
        if m == 1 or m == 3 or m == 5 or m == 7 or m == 8 or m == 10 or m == 12:
            if d >= 1 and d <= 31:
                booleano = True
                print(booleano)
            else:
                print('La fecha ingresada no es válida')
        if m == 4 or m == 6 or m == 9 or m == 11:
            if d >= 1 and d <= 30:
                booleano = True
                print(booleano)
            else:
                print('La fecha ingresada no es válida')
        if m == 2:
            if d >= 1 and d <= 29:  # se que aca no tengo en cuenta si es bisiesto, pero si lo es la fecha no va a estar en el registro asi que es lo mismo
                booleano = True
                print(booleano)
            else:
                print('La fecha ingresada no es válida')
    else:
        print('La fecha ingresada no es válida')
else:
    print('La fecha ingresada no es válida')

# Celda de prueba
print('A continuación se desplegaran las opciones disponibles:\n')
print('1- Gráfico comparativo de las empresas en el total de datos disponibles\n')
print('2- Calculo de intersecciones totales entre las empresas consideradas\n')
print('3- Comparación de crecimientos en un período determinado\n')
# 2 - Cálculo de intersecciones (crea intersecciones.xlsx, de existir el archivo lo sobreescribirá)
# 3 - Comparación de crecimientos en un período determinado (crea Crecimiento.xlsx, de existir lo sobreescirbirá)
# 4 - Cambiar empresas (empresas seleccionadas: )
# 5 - Cambiar formato de fecha (formato actual: )
# 6 - Salir o detener programa

# intersecciones que funcan
i = 0
inter = {'Date': [], 'Open': []}
if e1d['Open'][i] >= e2d['Open'][i]:
    e1mayor = True
elif e1d['Open'][i] < e2d['Open'][i]:
    e1mayor = False
tendencia = e1mayor
while i < len(e1d['Open']):
    if e1d['Open'][i] >= e2d['Open'][i]:
        e1mayor = True
    elif e1d['Open'][i] < e2d['Open'][i]:
        e1mayor = False
    if e1d['Open'][i] == e2d['Open'][i]:
        inter['Open'].append(e1d['Open'][i])
        inter['Date'].append(e1d['Date'][i])
    elif tendencia != e1mayor:
        inter['Open'].append(e1d['Open'][i])
        inter['Date'].append(e1d['Date'][i])
    i = i + 1
    tendencia = e1mayor

# Programa con menú


# Librerías utilizadas
# Función para limpiar la consola en CoLab


# Nombres de archivos y la extensión
nomInter = 'Intersecciones.xlsx'
nomCrec = 'Crecimiento.xlsx'
nomGraf = 'Gráfico.png'
extensión = '.csv'


# Base de datos
urls = {
    '^DJI': 'https://query1.finance.yahoo.com/v7/finance/download/%5EDJI?period1=475804800&period2=1605830400&interval=1d&events=history&includeAdjustedClose=true',
    'AMZN': 'https://query1.finance.yahoo.com/v7/finance/download/AMZN?period1=863654400&period2=1605830400&interval=1d&events=history&includeAdjustedClose=true',
    'BABA': 'https://query1.finance.yahoo.com/v7/finance/download/BABA?period1=1411084800&period2=1605830400&interval=1d&events=history&includeAdjustedClose=true',
    'GOOG': 'https://query1.finance.yahoo.com/v7/finance/download/GOOG?period1=1092873600&period2=1605830400&interval=1d&events=history&includeAdjustedClose=true',
}

# Descarga de los archivos si no existen en el directorio, para evitar repeticiones
for nombre, url in urls.items():
    if nombre + extensión not in os.listdir():
        archivo = requests.get(url)
        open(nombre + extensión, 'wb').write(archivo.content)


# Definición de funciones

# Función de cálculo de puntos de intersección
def calcInter(e1d, e2d, Date):
    i = 1
    inter = {'Date': [], 'Open': []}
    if e1d[-i] >= e2d[-i]:
        e1mayor = True
    elif e1d[-i] < e2d[-i]:
        e1mayor = False
    tendencia = e1mayor
    while i <= len(e1d) and i <= len(e2d):
        if e1d[-i] > e2d[-i]:
            e1mayor = True
        elif e1d[-i] < e2d[-i]:
            e1mayor = False
        else:
            inter['Open'].append(e1d[-i])
            inter['Date'].append(Date[-i])
        if tendencia != e1mayor:
            inter['Open'].append(e1d[-i])
            inter['Date'].append(Date[-i])
        tendencia = e1mayor
        i += 1
    return inter


# Función de derivada discreta
def deriv(lista):
    j = 0
    n = len(lista)
    d = []
    while j < n - 1:
        d.append(lista[j + 1] - lista[j])
        j = j + 1
    return d


# Función para validar fechas
def valid(a, m, d):
    booleano = False
    # Año
    a = int(a)
    # Mes
    m = int(m)
    # Día
    d = int(d)
    if a >= 1900:
        if m >= 1 and m <= 12:
            if m == 1 or m == 3 or m == 5 or m == 7 or m == 8 or m == 10 or m == 12:
                if d >= 1 and d <= 31:
                    booleano = True
                else:
                    print('La fecha ingresada no es válida')
            if m == 4 or m == 6 or m == 9 or m == 11:
                if d >= 1 and d <= 30:
                    booleano = True
                else:
                    print('La fecha ingresada no es válida')
            # Consideraciones especiales de febrero en caso de ser o no bisiesto
            if m == 2:
                if d >= 1 and d <= 29:
                    if a % 4 != 0 and d == 29:
                        print('La fecha ingresada no es válida')
                    else:
                        booleano = True
        else:
            print('La fecha ingresada no es válida')
    else:
        print('No se pueden seleccionar períodos anteriores al 1 de enero de 1900')
    if booleano == True:
        if dt.datetime.strptime(str(a) + str(m) + str(d), '%Y%m%d').date() >= dt.date.today() - dt.timedelta(days=1):
            print('Los datos son registros pasados, no se dispone de proyecciones')
            booleano = False
    return booleano


# Función para validar números
def entero(n):
    try:
        n = int(n)
        n = str(n)
        return True
    except ValueError:
        print('El valor {} ingresado no es válido, debe ser un número entero'.format(n))
        return False


# Programa

# Lista de empresas disponibles
directorio = os.listdir()

# Eliminación de valores indeseados en la lista del directorio
if os.name == 'nt':
    nomScript = __file__
    if nomScript in directorio:
        directorio.remove(nomScript)
if nomInter in directorio:
    directorio.remove(nomInter)
if nomCrec in directorio:
    directorio.remove(nomCrec)
if '.config' in directorio:
    directorio.remove('.config')
if 'sample_data' in directorio:
    directorio.remove('sample_data')
if '.ipynb_checkpoints' in directorio:
    directorio.remove('.ipynb_checkpoints')
if 'Gráfico.png' in directorio:
    directorio.remove('Gráfico.png')

# Definición de la lista de opciones
for x in range(0, len(directorio)):
    if '.csv' in directorio[x]:
        directorio[x] = directorio[x].replace(extensión, '')
print("Las opciones son:", directorio)

# Ingreso primera empresa
loop = True
while loop == True:
    e1 = input("Ingrese la primer empresa con la que desea trabajar: ").upper()
    if e1 in directorio:
        loop = False
    else:
        print('La empresa ingresada no se encuentra entre las opciones, vuelva a intentarlo')

# Ingreso segunda empresa
loop = True
while loop == True:
    e2 = input('Ingrese la segunda empresa con la que desea trabajar: ').upper()
    if e2 == e1:
        print('La empresa ya está seleccionada, ingrese otra')
    elif e2 in directorio:
        loop = False
    else:
        print('La empresa ingresada no se encuentra entre las opciones, vuelva a intentarlo')

# Definición de los data frame
e1df = pd.read_csv(e1 + ".csv")
e2df = pd.read_csv(e2 + ".csv")
pd.set_option('display.max_columns', 15)

# Definición de los diccionarios
e1d = e1df.to_dict("list")
e2d = e2df.to_dict("list")

# Definición de formato fechas
date1 = [dt.datetime.strptime(d, '%Y-%m-%d').date() for d in e1d['Date']]
date2 = [dt.datetime.strptime(d, '%Y-%m-%d').date() for d in e2d['Date']]


# Menú

# Definición de opciones
lista_opciones = [
    'Gráfico comparativo de las empresas en el total de datos disponibles',
    'Cálculo de intersecciones (crea el archivo ' + nomInter + ', de existir el archivo lo sobreescribirá)',
    'Grafico de derivadas',
    'Comparación de crecimientos en un período determinado (crea el archivo ' +
    nomCrec + ', de existir lo sobreescirbirá)',
    'Gráfico comparativo en un período seleccionado por el usuario',
    'Cambiar empresas',
    'Actualizar base de datos',
    'Salir o detener programa'
]
numOp = [n + 1 for n in range(len(lista_opciones))]


# Ingreso al bucle del menú
menu = True
while menu == True:

    # Limpiar consola
    clear_output()

    # Selección de opción
    loop = True
    while loop == True:
        print('Seleccione una de las siguientes opciones:')
        print('\n', end='')
        for item in numOp:
            print('{} - {}'.format(item, lista_opciones[item - 1]))
        print('\n')
        print('Las empresas seleccionadas en este momento son: {} y {}'.format(e1, e2))
        print('\n', end='')

        sleep(0.5)

        opcion = input('Opción seleccionada: ')
        if entero(opcion) == True and int(opcion) in numOp:
            loop = False
            opcion = int(opcion)
        else:
            clear_output()
            print('El valor ingresado no es válido, vuelva a intentar\n')

    # Limpiar consola
    clear_output()

    # Opciones
    n = 0

    # Formato para la creación de una nueva opción (también se debe agregar a lista_opciones en el mismo orden)

    # Opción: Nombre de la opción ingresado en lista_opciones
    # if opcion == numOp[n]:

    # Proceso que realiza la selección de esa opción

    # sleep(1)   (en caso de mostrar gráficos y usar el input)

    # input('Presione enter para volver al menú ') (en caso de necesitar ver los resultados)
    #n += 1

    # Opción: Gráfico comparativo de las empresas en el total de datos disponibles
    if opcion == numOp[n]:
        # Programa que compara dos empresas

        # Grafico
        plt.figure(figsize=[12, 4.8])
        plt.plot(date1, e1d['Open'], 'g--', label=e1)
        plt.plot(date2, e2d['Open'], 'm-', label=e2)
        plt.title('Comparación de empresas')
        plt.xlabel('Fechas')
        plt.ylabel('Open')
        plt.legend()

        # Puntos de intersección
        inter = calcInter(e1d['Open'], e2d['Open'], e1d['Date'])
        dateint = [dt.datetime.strptime(d, '%Y-%m-%d').date() for d in inter['Date']]
        plt.plot(dateint, inter['Open'], 'r.', label='Intersecciones')
        plt.title('Intersecciones')
        plt.xlabel('Fechas')
        plt.ylabel('Open')
        plt.legend()
        plt.show()

        sleep(1)

        input('Presione enter para volver al menú ')
    n += 1

    # Opción: Cálculo de intersecciones
    if opcion == numOp[n]:

        # Puntos de intersección
        inter = calcInter(e1d['Open'], e2d['Open'], e1d['Date'])
        dateint = [dt.datetime.strptime(d, '%Y-%m-%d').date() for d in inter['Date']]
        plt.figure(figsize=[12, 4.8])
        plt.plot(dateint, inter['Open'], 'r.', label='Intersecciones')
        plt.title('Intersecciones')
        plt.xlabel('Fechas')
        plt.ylabel('Open')
        plt.legend()
        plt.show()

        # Exportación de las intersecciones a excel
        archivo = pd.DataFrame(inter)
        archivo.to_excel(nomInter)

        sleep(1)

        input('Presione enter para volver al menú ')
    n += 1

    # Opción: Gráfico de derivada
    if opcion == numOp[n]:

        # Derivada discreta
        derivada1 = deriv(e1d['Open'])
        derivada2 = deriv(e2d['Open'])
        date_d1 = date1
        date_d1.pop()
        date_d2 = date2
        date_d2.pop()

        # Gráfico de la derivada discreta
        plt.figure(figsize=[12, 4.8])
        plt.plot(date_d1, derivada1, 'g--', label='Derivada discreta de ' + e1)
        plt.plot(date_d2, derivada2, 'm-', label='Derivada discreta de ' + e2)
        plt.title('Derivada discreta')
        plt.xlabel('Fechas')
        plt.ylabel('Valor de la derivada')
        plt.legend()
        plt.show()

        sleep(1)

        input('Presiones enter para volver al menú ')
    n += 1

    # Opción: Comparación de crecimientos en un período determinado
    if opcion == numOp[n]:

        # Crecimiento de empresas
        crec1df = pd.read_csv(e1 + ".csv", index_col='Date')
        crec2df = pd.read_csv(e2 + ".csv", index_col='Date')
        crec1d = crec1df.to_dict("index")
        crec2d = crec2df.to_dict("index")

        # Definición del dia de incio de octubre
        indicei = '2020-10-01'

        # Se le agrega días en caso de que caiga en fin de semana ya que no hay valores para esos dias
        if indicei not in crec1d:
            indicei = indicei[:-1] + str(int(indicei[-1:]) + 1)
        if indicei not in crec1d:
            indicei = indicei[:-1] + str(int(indicei[-1:]) + 1)

        # Definición del día de final de octubre
        indicef = '2020-10-31'

        # Se le resta días en caso de que caiga en fin de semana ya que no hay valores para esos dias
        if indicef not in crec1d:
            indicef = indicef[:-2] + str(int(indicef[-2:]) - 1)
        if indicef not in crec1d:
            indicef = indicef[:-2] + str(int(indicef[-2:]) - 1)

        crec1 = crec1d[indicef]['Open'] - crec1d[indicei]['Open']
        crec2 = crec2d[indicef]['Open'] - crec2d[indicei]['Open']

        # Comparación de ambos crecimientos
        if crec1 > crec2:
            print('La empresa que creció más en el mes de octubre es {}, con un valor de: {:.2f}\nLa empresa que creció menos en el mes de octubre es {}, con un valor de: {:.2f}'.format(e1, crec1, e2, crec2))
        elif crec2 > crec1:
            print('La empresa que creció más en el mes de octubre es {}, con un valor de: {:.2f}\nLa empresa que creció menos en el mes de octubre es {}, con un valor de: {:.2f}'.format(e2, crec2, e1, crec1))
        else:
            print('Ambas empresas experimentaron el mismo crecimiento en el mes de octubre, con un valor de: {}'.format(crec1))

        # Definición del dia de incio del mes septiembre
        indiceis = '2020-09-01'
        if indiceis not in crec1d:
            indiceis = indiceis[:-1] + str(int(indiceis[-1:]) + 1)
        if indiceis not in crec1d:
            indiceis = indiceis[:-1] + str(int(indiceis[-1:]) + 1)

        # Definición del día de final del mes
        indicefs = '2020-09-30'
        if indicefs not in crec1d:
            indicefs = indicefs[:-2] + str(int(indicefs[-2:]) - 1)
        if indicefs not in crec1d:
            indicefs = indicefs[:-2] + str(int(indicefs[-2:]) - 1)

        crec1s = crec1d[indicefs]['Open'] - crec1d[indiceis]['Open']
        crec2s = crec2d[indicefs]['Open'] - crec2d[indiceis]['Open']

        # Comparación de ambos crecimientos
        if crec1s > crec2s:
            print('La empresa que creció más en el mes de septiembre es {}, con un valor de: {:.2f}\nLa empresa que creció menos en el mes de septiembre es {}, con un valor de: {:.2f}'.format(e1, crec1s, e2, crec2s))
        elif crec2s > crec1s:
            print('La empresa que creció más en el mes de septiembre es {}, con un valor de: {:.2f}\nLa empresa que creció menos en el mes de septiembre es {}, con un valor de: {:.2f}'.format(e2, crec2s, e1, crec1s))
        else:
            print(
                'Ambas empresas experimentaron el mismo crecimiento en el mes de septiembre, con un valor de: {:.2f}'.format(crec1s))

        # Definición del dia de incio del año
        indiceia = '2019-11-20'
        if indiceia not in crec1d:
            indiceia = indiceia[:-1] + str(int(indiceia[-1:]) + 1)
        if indiceia not in crec1d:
            indiceia = indiceia[:-1] + str(int(indiceia[-1:]) + 1)

        # Definición del día de final del año
        indicefa = '2020-11-20'
        if indicefa not in crec1d:
            indicefa = indicefa[:-2] + str(int(indicefa[-2:]) - 1)
        if indicefa not in crec1d:
            indicefa = indicefa[:-2] + str(int(indicefa[-2:]) - 1)

        crec1a = crec1d[indicefa]['Open'] - crec1d[indiceia]['Open']
        crec2a = crec2d[indicefa]['Open'] - crec2d[indiceia]['Open']

        # Comparación de ambos crecimientos
        if crec1a > crec2a:
            print('La empresa que creció más en el último año es {}, con un valor de: {:.2f}\nLa empresa que creció menos en el último año es {}, con un valor de: {:.2f}'.format(
                e1, crec1a, e2, crec2a))
        elif crec2a > crec1a:
            print('La empresa que creció más en el último año es {}, con un valor de: {:.2f}\nLa empresa que creció menos en el último año es {}, con un valor de: {:.2f}'.format(
                e2, crec2a, e1, crec1a))
        else:
            print(
                'Ambas empresas experimentaron el mismo crecimiento en el último año, con un valor de: {:.2f}'.format(crec1a))

        # Exportacion a excel
        crecimientos = {'Empresa': [e1, e2], 'Crecimiento octubre': [crec1, crec2], 'Crecimiento septiembre': [
            crec1s, crec2s], 'Crecimiento anual (' + indicefa[:4] + ')': [crec1a, crec2a]}
        archivoCrec = pd.DataFrame(crecimientos)
        archivoCrec.to_excel(nomCrec)

        sleep(1)

        input('Presione enter para volver al menú ')
    n += 1

    # Opción: Gráfico comparativo en un período seleccionado por el usuario
    if opcion == numOp[n]:

        # Ingreso de fechas para comparar empresas
        loop = True
        while loop == True:

            # Ingreso fecha inicial
            corte = False
            while corte == False:
                dia1 = input('\nIngrese el día inicial:')
                mes1 = input('Ingrese el mes inicial:')
                año1 = input('Ingrese el año inicial:')
                if entero(dia1) == True and entero(mes1) == True and entero(año1) == True:
                    corte = valid(año1, mes1, dia1)

            # Definición de la fecha de inicio con su formato correspondiente
            fecha_inicio = str(int(año1)) + '-' + str(int(mes1)) + '-' + str(int(dia1))
            fecha_inicio = dt.datetime.strptime(fecha_inicio, '%Y-%m-%d').date()
            e1d['Date'] = date1

            # Se considera nuevamente si cae en fin de semana
            if fecha_inicio not in e1d['Date']:
                fecha_inicio = fecha_inicio + dt.timedelta(days=1)
            if fecha_inicio not in e1d['Date']:
                fecha_inicio = fecha_inicio + dt.timedelta(days=1)

            # Ingreso de fecha final
            corte = False
            while corte == False:
                dia2 = input('\nIngrese el día final:')
                mes2 = input('Ingrese el mes final:')
                año2 = input('Ingrese el año final:')
                if entero(dia2) == True and entero(mes2) == True and entero(año2) == True:
                    corte = valid(año2, mes2, dia2)

            # Definición de la fecha de inicio con su formato correspondiente
            fecha_final = str(int(año2)) + '-' + str(int(mes2)) + '-' + str(int(dia2))
            fecha_final = dt.datetime.strptime(fecha_final, '%Y-%m-%d').date()

            # Se considera nuevamente si cae en fin de semana
            if fecha_final not in e1d['Date']:
                fecha_final = fecha_final - dt.timedelta(days=1)
            if fecha_final not in e1d['Date']:
                fecha_final = fecha_final - dt.timedelta(days=1)

            # Verificación si la fecha inicial es anterior a la final
            if fecha_final > fecha_inicio:
                loop = False
            else:
                print('La fecha de inicio debe ser anterior a la fecha final del período selecionado, vuelva a ingresar los datos')

        # Definición de listas de los períodos definidos por el usuario
        fecha_usu1 = []
        fecha_usu2 = []
        dato1_usu = []
        dato2_usu = []
        rango_usu1 = True
        rango_usu2 = True

        # Lista para la empresa 1 de los períodos definidos por el usuario
        for largo in range(0, len(date1)):
            if rango_usu1 == True:
                if largo < len(date1) and fecha_inicio <= date1[largo]:
                    fecha_usu1.append(date1[largo])
                    dato1_usu.append(e1d['Open'][largo])
                if fecha_final <= date1[largo]:
                    rango_usu1 = False

        # Lista para la empresa 2 de los períodos definidos por el usuario
        for largo2 in range(0, len(date2)):
            if rango_usu2 == True:
                if largo2 < len(date2) and fecha_inicio <= date2[largo2]:
                    fecha_usu2.append(date2[largo2])
                    dato2_usu.append(e2d['Open'][largo2])
                if fecha_final <= date2[largo2]:
                    rango_usu2 = False

        # Intersecciones del gráfico definido por el usuario
        inter_usu = calcInter(dato1_usu, dato2_usu, fecha_usu1)

        # Grafico definido por el usuario
        plt.figure(figsize=[12, 4.8])
        plt.plot(fecha_usu1, dato1_usu, 'g--', label=e1)
        plt.plot(fecha_usu2, dato2_usu, 'm-', label=e2)
        plt.plot(inter_usu['Date'], inter_usu['Open'], 'r.', label='Intersecciones')
        plt.title('Comparación en rango')
        plt.xlabel('Fechas')
        plt.ylabel('Open')
        plt.legend()
        plt.savefig(nomGraf)
        plt.show()

        sleep(1)

        input('Presione enter para volver al menú ')
    n += 1

    # Opción: Cambiar empresas
    if opcion == numOp[n]:
        # Lista de empresas
        print("Las empresas registradas en la base de datos son:", directorio)

        # Ingreso primera empresa
        loop = True
        while loop == True:
            e1 = input("Ingrese la primer empresa con la que desea trabajar:").upper()
            if e1 in directorio:
                loop = False
            else:
                print('La empresa ingresada no se encuentra entre las opciones, vuelva a intentarlo')

        # Ingreso segunda empresa
        loop = True
        while loop == True:
            e2 = input('Ingrese la segunda empresa con la que desea trabajar:').upper()
            if e2 == e1:
                print('La empresa ya está seleccionada, ingrese otra')
            elif e2 in directorio:
                loop = False
            else:
                print('La empresa ingresada no se encuentra entre las opciones, vuelva a intentarlo')

        # Definición de los data frame
        e1df = pd.read_csv(e1 + ".csv")
        e2df = pd.read_csv(e2 + ".csv")
        pd.set_option('display.max_columns', 15)

        # Definición de los diccionarios
        e1d = e1df.to_dict("list")
        e2d = e2df.to_dict("list")

        # Definición de formato fechas
        date1 = [dt.datetime.strptime(d, '%Y-%m-%d').date() for d in e1d['Date']]
        date2 = [dt.datetime.strptime(d, '%Y-%m-%d').date() for d in e2d['Date']]

    n += 1

    # Opción: Actualizar base de datos
    if opcion == numOp[n]:

        # Descarga y sobreescribe todos los archivos con datos de las empresas
        for nombre, url in urls.items():
            archivo = requests.get(url)
            open(nombre + extensión, 'wb').write(archivo.content)

        print('Base de datos actualizada')
        sleep(2)
    n += 1

    #Opción: Salir
    if opcion == numOp[n]:
        menu = False


# Fin del menú

print('El programa ha finalizado ¿Ya puede aprobarnos? :D')

# Librerías utilizadas
# Función para limpiar la consola


# Nombres de archivos y la extensión
nomInter = 'Intersecciones.xlsx'
nomCrec = 'Crecimiento.xlsx'
nomGraf = 'Gráfico.png'
extensión = '.csv'


# Base de datos
urls = {
    '^DJI': 'https://query1.finance.yahoo.com/v7/finance/download/%5EDJI?period1=475804800&period2=1605830400&interval=1d&events=history&includeAdjustedClose=true',
    'AMZN': 'https://query1.finance.yahoo.com/v7/finance/download/AMZN?period1=863654400&period2=1605830400&interval=1d&events=history&includeAdjustedClose=true',
    'BABA': 'https://query1.finance.yahoo.com/v7/finance/download/BABA?period1=1411084800&period2=1605830400&interval=1d&events=history&includeAdjustedClose=true',
    'GOOG': 'https://query1.finance.yahoo.com/v7/finance/download/GOOG?period1=1092873600&period2=1605830400&interval=1d&events=history&includeAdjustedClose=true',
}

directorio = os.listdir()
# Descarga de los archivos si no existen en el directorio, para evitar repeticiones
for nombre, url in urls.items():
    if nombre + extensión not in directorio:
        archivo = requests.get(url)
        open(nombre + extensión, 'wb').write(archivo.content)


# Definición de funciones

# Función de cálculo de puntos de intersección
def calcInter(e1d, e2d, Date):
    i = 1
    inter = {'Date': [], 'Open': []}
    if e1d[-i] >= e2d[-i]:
        e1mayor = True
    elif e1d[-i] < e2d[-i]:
        e1mayor = False
    tendencia = e1mayor
    while i <= len(e1d) and i <= len(e2d):
        if e1d[-i] > e2d[-i]:
            e1mayor = True
        elif e1d[-i] < e2d[-i]:
            e1mayor = False
        else:
            inter['Open'].append(e1d[-i])
            inter['Date'].append(Date[-i])
        if tendencia != e1mayor:
            inter['Open'].append(e1d[-i])
            inter['Date'].append(Date[-i])
        tendencia = e1mayor
        i += 1
    return inter


# Función de derivada discreta
def deriv(lista):
    j = 0
    n = len(lista)
    d = []
    while j < n - 1:
        d.append(lista[j + 1] - lista[j])
        j = j + 1
    return d


# Función para validar fechas
def valid(a, m, d):
    booleano = False
    # Año
    a = int(a)
    # Mes
    m = int(m)
    # Día
    d = int(d)
    if m >= 1 and m <= 12:
        if m == 1 or m == 3 or m == 5 or m == 7 or m == 8 or m == 10 or m == 12:
            if d >= 1 and d <= 31:
                booleano = True
            else:
                print('La fecha ingresada no es válida')
        if m == 4 or m == 6 or m == 9 or m == 11:
            if d >= 1 and d <= 30:
                booleano = True
            else:
                print('La fecha ingresada no es válida')
        # Consideraciones especiales de febrero en caso de ser o no bisiesto
        if m == 2:
            if d >= 1 and d <= 29:
                if a % 4 != 0 and d == 29:
                    print('La fecha ingresada no es válida')
                else:
                    booleano = True
    else:
        print('La fecha ingresada no es válida')
    if booleano == True:
        if dt.datetime.strptime(str(a) + str(m) + str(d), '%Y%m%d').date() >= dt.date.today() - dt.timedelta(days=1):
            print('Los datos son registros pasados, no se dispone de proyecciones')
            booleano = False
    return booleano


# Función para validar números
def entero(n):
    try:
        n = int(n)
        n = str(n)
        return True
    except ValueError:
        print('El valor {} ingresado no es válido, debe ser un número entero'.format(n))
        return False


# Programa

# Lista de empresas disponibles
directorio = os.listdir()

# Eliminación de valores indeseados en la lista del directorio
if nomInter in directorio:
    directorio.remove(nomInter)
if nomCrec in directorio:
    directorio.remove(nomCrec)
if '.config' in directorio:
    directorio.remove('.config')
if 'sample_data' in directorio:
    directorio.remove('sample_data')
if '.ipynb_checkpoints' in directorio:
    directorio.remove('.ipynb_checkpoints')
if 'Gráfico.png' in directorio:
    directorio.remove('Gráfico.png')

# Definición de la lista de opciones
for x in range(0, len(directorio)):
    if '.csv' in directorio[x]:
        directorio[x] = directorio[x].replace(extensión, '')
print("Las opciones son:", directorio)

# Ingreso primera empresa
loop = True
while loop == True:
    e1 = input("Ingrese la primer empresa con la que desea trabajar: ").upper()
    if e1 in directorio:
        loop = False
    else:
        print('La empresa ingresada no se encuentra entre las opciones, vuelva a intentarlo')

# Ingreso segunda empresa
loop = True
while loop == True:
    e2 = input('Ingrese la segunda empresa con la que desea trabajar: ').upper()
    if e2 == e1:
        print('La empresa ya está seleccionada, ingrese otra')
    elif e2 in directorio:
        loop = False
    else:
        print('La empresa ingresada no se encuentra entre las opciones, vuelva a intentarlo')

# Definición de los data frame
e1df = pd.read_csv(e1 + ".csv")
e2df = pd.read_csv(e2 + ".csv")
pd.set_option('display.max_columns', 15)

# Definición de los diccionarios
e1d = e1df.to_dict("list")
e2d = e2df.to_dict("list")

# Definición de formato fechas
date1 = [dt.datetime.strptime(d, '%Y-%m-%d').date() for d in e1d['Date']]
date2 = [dt.datetime.strptime(d, '%Y-%m-%d').date() for d in e2d['Date']]

# Programa que compara dos empresas

# Graficos
plt.figure(figsize=[12, 4.8])
plt.plot(date1, e1d['Open'], 'g--', label=e1)
plt.plot(date2, e2d['Open'], 'm-', label=e2)
plt.title('Comparación de empresas')
plt.xlabel('Fechas')
plt.ylabel('Open')
plt.legend()


# Puntos de intersección
inter = calcInter(e1d['Open'], e2d['Open'], e1d['Date'])
dateint = [dt.datetime.strptime(d, '%Y-%m-%d').date() for d in inter['Date']]
# En caso de querer gráficar las intersecciones sobre el grafico anterior bastara con comentar la siguiente linea ("plt.figure(figsize=[12,4.8])")
plt.figure(figsize=[12, 4.8])
plt.plot(dateint, inter['Open'], 'r.', label='Intersecciones')
plt.title('Intersecciones')
plt.xlabel('Fechas')
plt.ylabel('Open')
plt.legend()
plt.show()


# Exportación de las intersecciones a excel
archivo = pd.DataFrame(inter)
archivo.to_excel(nomInter)


# Derivada discreta
derivada1 = deriv(e1d['Open'])
derivada2 = deriv(e2d['Open'])
date_d1 = date1
date_d1.pop()
date_d2 = date2
date_d2.pop()

# Gráfico de la derivada discreta
plt.figure(figsize=[12, 4.8])
plt.plot(date_d1, derivada1, 'g--', label='Derivada discreta de ' + e1)
plt.plot(date_d2, derivada2, 'm-', label='Derivada discreta de ' + e2)
plt.title('Derivada discreta')
plt.xlabel('Fechas')
plt.ylabel('Valor de la derivada')
plt.legend()
plt.show()


# Crecimiento de empresas
crec1df = pd.read_csv(e1 + ".csv", index_col='Date')
crec2df = pd.read_csv(e2 + ".csv", index_col='Date')
crec1d = crec1df.to_dict("index")
crec2d = crec2df.to_dict("index")

# Definición del dia de incio de octubre
indicei = '2020-10-01'

# Se le agrega días en caso de que caiga en fin de semana ya que no hay valores para esos dias
if indicei not in crec1d:
    indicei = indicei[:-1] + str(int(indicei[-1:]) + 1)
if indicei not in crec1d:
    indicei = indicei[:-1] + str(int(indicei[-1:]) + 1)

# Definición del día de final de octubre
indicef = '2020-10-31'

# Se le resta días en caso de que caiga en fin de semana ya que no hay valores para esos dias
if indicef not in crec1d:
    indicef = indicef[:-2] + str(int(indicef[-2:]) - 1)
if indicef not in crec1d:
    indicef = indicef[:-2] + str(int(indicef[-2:]) - 1)

crec1 = crec1d[indicef]['Open'] - crec1d[indicei]['Open']
crec2 = crec2d[indicef]['Open'] - crec2d[indicei]['Open']

# Comparación de ambos crecimientos
if crec1 > crec2:
    print('La empresa que creció más en el mes de octubre es {}, con un valor de: {:.2f}\nLa empresa que creció menos en el mes de octubre es {}, con un valor de: {:.2f}'.format(e1, crec1, e2, crec2))
elif crec2 > crec1:
    print('La empresa que creció más en el mes de octubre es {}, con un valor de: {:.2f}\nLa empresa que creció menos en el mes de octubre es {}, con un valor de: {:.2f}'.format(e2, crec2, e1, crec1))
else:
    print('Ambas empresas experimentaron el mismo crecimiento en el mes de octubre, con un valor de: {}'.format(crec1))


# Definición del dia de incio del mes septiembre
indiceis = '2020-09-01'
if indiceis not in crec1d:
    indiceis = indiceis[:-1] + str(int(indiceis[-1:]) + 1)
if indiceis not in crec1d:
    indiceis = indiceis[:-1] + str(int(indiceis[-1:]) + 1)

# Definición del día de final del mes
indicefs = '2020-09-30'
if indicefs not in crec1d:
    indicefs = indicefs[:-2] + str(int(indicefs[-2:]) - 1)
if indicefs not in crec1d:
    indicefs = indicefs[:-2] + str(int(indicefs[-2:]) - 1)

crec1s = crec1d[indicefs]['Open'] - crec1d[indiceis]['Open']
crec2s = crec2d[indicefs]['Open'] - crec2d[indiceis]['Open']

# Comparación de ambos crecimientos
if crec1s > crec2s:
    print('La empresa que creció más en el mes de septiembre es {}, con un valor de: {:.2f}\nLa empresa que creció menos en el mes de septiembre es {}, con un valor de: {:.2f}'.format(e1, crec1s, e2, crec2s))
elif crec2s > crec1s:
    print('La empresa que creció más en el mes de septiembre es {}, con un valor de: {:.2f}\nLa empresa que creció menos en el mes de septiembre es {}, con un valor de: {:.2f}'.format(e2, crec2s, e1, crec1s))
else:
    print(
        'Ambas empresas experimentaron el mismo crecimiento en el mes de septiembre, con un valor de: {:.2f}'.format(crec1s))


# Definición del dia de incio del año
indiceia = '2019-11-20'
if indiceia not in crec1d:
    indiceia = indiceia[:-1] + str(int(indiceia[-1:]) + 1)
if indiceia not in crec1d:
    indiceia = indiceia[:-1] + str(int(indiceia[-1:]) + 1)

# Definición del día de final del año
indicefa = '2020-11-20'
if indicefa not in crec1d:
    indicefa = indicefa[:-2] + str(int(indicefa[-2:]) - 1)
if indicefa not in crec1d:
    indicefa = indicefa[:-2] + str(int(indicefa[-2:]) - 1)

crec1a = crec1d[indicefa]['Open'] - crec1d[indiceia]['Open']
crec2a = crec2d[indicefa]['Open'] - crec2d[indiceia]['Open']

# Comparación de ambos crecimientos
if crec1a > crec2a:
    print('La empresa que creció más en el año {0} es {1}, con un valor de: {2:.2f}\nLa empresa que creció menos en el año {0} es {3}, con un valor de: {4:.2f}'.format(
        indicefa[:4], e1, crec1a, e2, crec2a))
elif crec2a > crec1a:
    print('La empresa que creció más en el año {0} es {1}, con un valor de: {2:.2f}\nLa empresa que creció menos en el año {0} es {3}, con un valor de: {4:.2f}'.format(
        indicefa[:4], e2, crec2a, e1, crec1a))
else:
    print('Ambas empresas experimentaron el mismo crecimiento en el año {}, con un valor de: {:.2f}'.format(
        indicefa[:4], crec1a))


# Exportacion a excel
crecimientos = {'Empresa': [e1, e2], 'Crecimiento octubre': [crec1, crec2], 'Crecimiento septiembre': [
    crec1s, crec2s], 'Crecimiento anual (' + indicefa[:4] + ')': [crec1a, crec2a]}
archivoCrec = pd.DataFrame(crecimientos)
archivoCrec.to_excel(nomCrec)


# Ingreso de fechas para comparar empresas
loop = True
while loop == True:

    # Ingreso fecha inicial
    corte = False
    while corte == False:
        dia1 = input('\nIngrese el día inicial:')
        mes1 = input('Ingrese el mes inicial:')
        año1 = input('Ingrese el año inicial:')
        if entero(dia1) == True and entero(mes1) == True and entero(año1) == True:
            corte = valid(año1, mes1, dia1)

    # Definición de la fecha de inicio con su formato correspondiente
    fecha_inicio = año1 + '-' + mes1 + '-' + dia1
    fecha_inicio = dt.datetime.strptime(fecha_inicio, '%Y-%m-%d').date()
    e1d['Date'] = date1

    # Se considera nuevamente si cae en fin de semana
    if fecha_inicio not in e1d['Date']:
        fecha_inicio = fecha_inicio + dt.timedelta(days=1)
    if fecha_inicio not in e1d['Date']:
        fecha_inicio = fecha_inicio + dt.timedelta(days=1)

    # Ingreso de fecha final
    corte = False
    while corte == False:
        dia2 = input('\nIngrese el día final:')
        mes2 = input('Ingrese el mes final:')
        año2 = input('Ingrese el año final:')
        if entero(dia2) == True and entero(mes2) == True and entero(año2) == True:
            corte = valid(año2, mes2, dia2)

    # Definición de la fecha de inicio con su formato correspondiente
    fecha_final = año2 + '-' + mes2 + '-' + dia2
    fecha_final = dt.datetime.strptime(fecha_final, '%Y-%m-%d').date()

    # Se considera nuevamente si cae en fin de semana
    if fecha_final not in e1d['Date']:
        fecha_final = fecha_final - dt.timedelta(days=1)
    if fecha_final not in e1d['Date']:
        fecha_final = fecha_final - dt.timedelta(days=1)

    # Verificación si la fecha inicial es anterior a la final
    if fecha_final > fecha_inicio:
        loop = False
    else:
        print('La fecha de inicio debe ser anterior a la fecha final del período selecionado, vuelva a ingresar los datos')


# Definición de listas de los períodos definidos por el usuario
fecha_usu1 = []
fecha_usu2 = []
dato1_usu = []
dato2_usu = []
rango_usu1 = True
rango_usu2 = True

# Lista para la empresa 1 de los períodos definidos por el usuario
for largo in range(0, len(date1)):
    if rango_usu1 == True:
        if largo < len(date1) and fecha_inicio <= date1[largo]:
            fecha_usu1.append(date1[largo])
            dato1_usu.append(e1d['Open'][largo])
    if fecha_final <= date1[largo]:
        rango_usu1 = False

# Lista para la empresa 2 de los períodos definidos por el usuario
for largo2 in range(0, len(date2)):
    if rango_usu2 == True:
        if largo2 < len(date2) and fecha_inicio <= date2[largo2]:
            fecha_usu2.append(date2[largo2])
            dato2_usu.append(e2d['Open'][largo2])
    if fecha_final <= date2[largo2]:
        rango_usu2 = False


# Intersecciones del gráfico definido por el usuario
inter_usu = calcInter(dato1_usu, dato2_usu, fecha_usu1)

# Grafico definido por el usuario
plt.figure(figsize=[12, 4.8])
plt.plot(fecha_usu1, dato1_usu, 'g--', label=e1)
plt.plot(fecha_usu2, dato2_usu, 'm-', label=e2)
plt.plot(inter_usu['Date'], inter_usu['Open'], 'r.', label='Intersecciones')
plt.title('Comparación en rango')
plt.xlabel('Fechas')
plt.ylabel('Open')
plt.legend()
plt.savefig(nomGraf)
plt.show()


# Posibilidad de que se ingresen más de dos empresas (con una lista), quizá muy ambicioso, pero no sé por qué no lo empezamos haciendo así. Cosas a tener en cuenta, no puede haber más empresas seleccionadas que cantidad de empresas disponibles (que corte si el largo de la lista de empresas ingresadas igual al del directorio), comparar en cada ingreso que no se repitan, para los graficos usar un for o un while con el largo de la lista ingresada, que corte con un enter o un nada.

# Menú para realizar acciones después de ingresar las primeras 2 empresas
# Acciones:
# 1 - Gráfico comparativo
# 2 - Cálculo de intersecciones (crea intersecciones.xlsx, de existir el archivo lo sobreescribirá)
# 3 - Comparación de crecimientos en un período determinado (crea Crecimiento.xlsx, de existir lo sobreescirbirá)
# 4 - Cambiar empresas (empresas seleccionadas: )
# 5 - Cambiar formato de fecha (formato actual: )
# 6 - Salir o detener programa

# Para el menú probablemente tengamos que buscar como borrar lo que se muestra
# aca habria q comparar si esas fechas estan en los datos y extraer los valores

"""**Funcionalidad opcional:** *Pueden realizar todos, algunos, o ninguno de los siguientes ítems. También pueden agregar otra funcionalidad que se les ocurra a ustedes en tanto cumpla con la funcionalidad mínima.*

* El usuario debe poder seleccionar un periodo (1 semana, 1 mes, etc) y fechas de comienzo y de final. El programa debe poder analizar dentro de esas fechas las empresas que crecieron más y menos dentro de cada periodo (1 semana, 1 mes, etc).

* El usuario debe poder ingresar una fecha de inicio y de fin, luego el programa analiza para cada empresa aquella que tenga el mayor coeficiente de correlación lineal (aquella que mejor se aproxime a una recta). Pueden utilizar la función [scipy.stats.pearsonr](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.pearsonr.html) de la librería *scipy*.

* Mostrar la pendiente obtenida al aproximar el precio de cada empresa mediante una ecuación lineal, ofrecer la opción de visualizar el precio de cierta empresa superponiendo esta aproximación lineal en el gráfico. Pueden utilizar la función [scipy.stats.linregress](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.linregress.html) de la librería *scipy*.

  **Atención:** La matemática para hacer estos análisis puede resultar avanzada y no es necesario entenderla, alcanza con entender el funcionamiento de las funciones de librería y saber aplicarlas correctamente.

* Para cada gráfico generado el usuario deberá poder ingresar un nombre de archivo y el programa genera un archivo *.PNG* del gráfico con el nombre indicado.

* Crear una aplicación de consola que se ejecute continuamente recibiendo comandos del usuario, el usuario debe indicar el modo de operación que desea y el programa le pide los datos requeridos. Luego de finalizar la tarea el programa regresa al inicio y le pide al usuario el próximo comando. Incluír un comando de *ayuda* para que el programa indique al usuario cómo utilizarlo. Incluír un comando de *salida* que provoca la finalización del programa.

# **Opción 3: Análisis de datos obtenidos por un instrumento de medición**

#### *Analisis de una señal de un electrocardiograma para conseguir información de un paciente.*

<img height="300" src="https://cdn.pixabay.com/photo/2017/04/29/13/16/ecg-2270728_960_720.jpg">

Un electrocardiograma es una representación gráfica de los pulsos cardíacos. Se tiene un archivo **electrocardiograma.xlsx** con la información del resultado de un electrocardiograma en dos columnas, una tiene los valores de las mediciones en $eV$ (columna *señal*), y la segunda los instantes (medido en segundos transcurridos) en que se toma cada medición (columna *tiempo*) que fueron tomadas con una frecuencia de 360 Hz.

**Funcionalidad mínima (requisito):**

*   Se debe poder calcular los picos de la señal y marcarlos en un gráfico de la misma.

    **Sugerencia**: Usar la función [scipy.signal.find_peaks](https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.find_peaks.html) de la librería *scipy* (en la documentación hay ejemplos muy útiles).

*   Se debe poder calcular la frecuencia cardíaca del paciente medida en latidos por minuto a partir de los picos más altos de cada pulsación.

*   Determinar si el electrocardiograma fue tomado mientras el paciente dormía, estaba en reposo o hacia actividad física. Tomar como referencia los [criterios de la frecuencia cardíaca](https://es.wikipedia.org/wiki/Frecuencia_card%C3%ADaca) y pedir como entrada del programa cualquier información adicional necesaria (como la edad o el sexo del paciente).

*   Se deben poder almacenar los resultados en un archivo de texto *.txt*

**Gráfico a entregar (requisito):**

* Graficar la señal del electrocardiograma en función del tiempo señalando el pico más alto de cada pulsación. Indicar la frecuencia cardíaca dentro del gráfico (puede ser mediante *labels*, *título*, *descripción*, etc).

**Funcionalidad opcional:** *Pueden realizar todos, algunos, o ninguno de los siguientes ítems. También pueden agregar otra funcionalidad que se les ocurra a ustedes en tanto cumpla con la funcionalidad mínima.*

* Identificar la onda P, el complejo QRS y la onda T para cada pulsación. Pueden investigar más en [esta página de Wikipedia](https://es.wikipedia.org/wiki/Electrocardiograma#El_ECG_normal).

* Analizar y graficar la [densidad espectral de potencia](https://es.wikipedia.org/wiki/Densidad_espectral) de la señal, calcular su valor en 60 Hz (la frecuencia de la instalación eléctrica donde se realizaron las mediciones) para averiguar si la instalación eléctrica afecta a la medición. Para esto pueden utilizar la función [scipy.signal.welch](https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.welch.html) de la librería *scipy*.

  **Atención:** La matemática para hacer este análisis puede resultar avanzada y no es necesario entenderla, alcanza con entender el funcionamiento de las funciones de librería y saber aplicarlas correctamente.

* Para cada gráfico generado el usuario deberá poder ingresar un nombre de archivo y el programa genera un archivo *.PNG* del gráfico con el nombre indicado.

* Crear una aplicación de consola que se ejecute continuamente recibiendo comandos del usuario, el usuario debe indicar el modo de operación que desea y el programa le pide los datos requeridos. Luego de finalizar la tarea el programa regresa al inicio y le pide al usuario el próximo comando. Incluír un comando de *ayuda* para que el programa indique al usuario cómo utilizarlo. Incluír un comando de *salida* que provoca la finalización del programa.

Para descargar los datos ejecutar: wget "https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/Clase_4_datos/electrocardiograma.xlsx"
"""
